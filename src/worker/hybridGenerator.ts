import { supabaseAdmin } from '@/lib/supabase/server'
import { generateLesson } from './generator'
import {
  determineStrategy,
  analyzeComplexity,
  getLessonConfig,
  logRoutingDecision,
  GenerationStrategy
} from '@/config/generationConfig'
import { MultiAgentOrchestrator } from '@/agents/orchestrator'
import { convertContentToTypeScript, addThinkingComments } from '@/agents/codeConverter'
import { compileTypeScript } from './compiler'
import { callLLM } from './llm'
import { COMPONENT_GENERATION_PROMPT, COMPONENT_FIX_PROMPT } from './componentPrompt'
import { PRIMARY_PROMPT } from './prompts'
import { LessonPlan } from '@/agents/planner'
import { ContentEnhancer } from './contentEnhancer'
import { AdvancedQualityScorer } from './advancedQualityScorer'
// Removed unused imports - now using component kit multi-agent system

/**
 * Hybrid generator that intelligently routes between single-agent
 * and multi-agent approaches based on complexity and requirements
 */
export async function generateLessonHybrid(lessonId: string): Promise<void> {
  const { data: lesson } = await (supabaseAdmin
    .from('lessons') as any)
    .select('*')
    .eq('id', lessonId)
    .single()

  if (!lesson) {
    throw new Error(`Lesson ${lessonId} not found`)
  }

  // Get configuration for this lesson
  const config = await getLessonConfig(lessonId)
  
  // Analyze complexity
  const complexity = analyzeComplexity(lesson.outline)
  
  // Determine which strategy to use (optionally disable planner)
  const strategy = determineStrategy(lesson.outline, config)
  const enablePlanner = (process.env.ENABLE_MULTI_AGENT_PLANNER || 'true').toLowerCase() !== 'false'
  
  // Log routing decision
  logRoutingDecision(lessonId, lesson.outline, strategy, complexity, config)
  console.log('[Hybrid] Routing summary:', {
    lessonId,
    strategy,
    complexity,
    config
  })
  
  // Route to appropriate generator
  if (strategy === 'multi' && enablePlanner) {
    console.log(`[Hybrid] Dispatching to multi-agent for ${lessonId}`)
    try {
      return await generateLessonMultiAgent(lessonId, lesson.outline, complexity)
    } catch (e) {
      console.log('[Hybrid] Planner/multi-agent path unavailable, routing to single-agent')
      return await generateLesson(lessonId)
    }
  } else {
    console.log(`[Hybrid] Dispatching to single-agent for ${lessonId}`)
    return await generateLesson(lessonId)
  }
}

/**
 * Generate lesson using multi-agent approach
 */
async function generateLessonMultiAgent(
  lessonId: string,
  outline: string,
  complexity: number
): Promise<void> {
  console.log(`[Hybrid] Using multi-agent for lesson ${lessonId} (complexity: ${complexity})`)
  
  await (supabaseAdmin
    .from('lessons') as any)
    .update({ status: 'generating' })
    .eq('id', lessonId)

  const orchestrator = new MultiAgentOrchestrator()
  
  try {
    // Generate content using multi-agent system
    const result = await orchestrator.generateContent(outline)
    
    if (!result.success) {
      throw new Error('Multi-agent generation failed')
    }
    
    console.log('[Hybrid] Multi-agent content generated:', {
      plan: result.plan.lessonType,
      content: result.content.title,
      duration: result.totalDurationMs
    })
    
    // Use the component kit multi-agent system to generate the React component
    console.log('[Hybrid] Using component kit multi-agent system...')
    
    const { orchestrateComponentGeneration } = await import('./componentKit/orchestrator')
    
    const componentResult = await orchestrateComponentGeneration({
      topic: outline, // Use the original outline instead of plan.lessonType
      pedagogy: {
        gradeBand: '3-5',
        readingLevel: 'basic',
        languageTone: 'friendly',
        cognitiveLoad: 'medium',
        accessibility: {
          minFontSizePx: 16,
          highContrast: true,
          captionsPreferred: false
        }
      },
      lessonId: lessonId
    })
    
    if (!componentResult.success) {
      throw new Error('Component kit generation failed')
    }
    
    const reactComponent = componentResult.tsxSource
    
    if (!reactComponent) {
      throw new Error('No React component generated by component kit')
    }
    
    console.log('[Hybrid] React component generated from multi-agent plan, enhancing quality...')
    
    // Enhance content quality
    const contentEnhancer = new ContentEnhancer()
    const enhancementResult = await contentEnhancer.enhanceContent(
      reactComponent, 
      outline, 
      '3-5' // Default grade band
    )
    
    console.log('[Hybrid] Content enhancement complete:', {
      qualityImprovement: enhancementResult.qualityImprovement,
      stagesApplied: enhancementResult.stagesApplied.length,
      recommendations: enhancementResult.recommendations.length
    })
    
    // Use enhanced component
    const finalComponent = enhancementResult.enhancedCode
    
    console.log('[Hybrid] Compiling enhanced component...')
    
    // Compile TypeScript
    const compilationResult = await compileTypeScript(finalComponent)
    
    if (!compilationResult.success) {
      console.error('[Hybrid] Compilation failed:', compilationResult.tscErrors)
      
      // Save failure trace
      await saveMultiAgentTrace(lessonId, result, complexity, false)
      
      // No component fix loop in legacy path
      
      // Fall back to single-agent
      console.log('[Hybrid] Falling back to single-agent approach')
      return await generateLesson(lessonId)
    }
    
    console.log('[Hybrid] Compilation successful')
    
    // Save content (upsert to prevent duplicates)
    await (supabaseAdmin
      .from('lesson_contents') as any)
      .upsert({
        lesson_id: lessonId,
        typescript_source: finalComponent,
        compiled_js: compilationResult.compiledJs,
        version: 1
      }, {
        onConflict: 'lesson_id'
      })
    
    // Save multi-agent trace
    await saveMultiAgentTrace(lessonId, result, complexity, true)
    
    // Update lesson status
    await (supabaseAdmin
      .from('lessons') as any)
      .update({ status: 'generated' })
      .eq('id', lessonId)
    
    console.log(`[Hybrid] Multi-agent generation complete for lesson ${lessonId}`)
    
  } catch (error) {
    console.error('[Hybrid] Multi-agent generation error:', error)
    
    // Try falling back to single-agent
    try {
      console.log('[Hybrid] Attempting fallback to single-agent')
      await generateLesson(lessonId)
    } catch (fallbackError) {
      // Both failed, mark as failed and save failure trace
      await (supabaseAdmin
        .from('lessons') as any)
        .update({ status: 'failed' })
        .eq('id', lessonId)
      
      // Save failure trace for debugging
      try {
        await (supabaseAdmin.from('traces') as any).insert({
          lesson_id: lessonId,
          attempt_number: 1,
          prompt: 'Hybrid generation failure - both multi-agent and single-agent failed',
          model: 'hybrid-error',
          response: '',
          tokens: null,
          validation: { 
            passed: false, 
            errors: [
              `Multi-agent error: ${error instanceof Error ? error.message : 'Unknown error'}`,
              `Single-agent error: ${fallbackError instanceof Error ? fallbackError.message : 'Unknown error'}`
            ]
          },
          compilation: { 
            success: false, 
            error: 'Both generation strategies failed'
          },
          error: `Multi-agent: ${error instanceof Error ? error.message : 'Unknown error'}; Single-agent: ${fallbackError instanceof Error ? fallbackError.message : 'Unknown error'}`
        })
      } catch (traceError) {
        console.error('[Hybrid] Failed to save failure trace:', traceError)
      }
      
      throw error
    }
  }
}

/**
 * Save multi-agent trace to database
 */
async function saveMultiAgentTrace(
  lessonId: string,
  result: any,
  complexity: number,
  success: boolean
): Promise<void> {
  try {
    // Check if multi_agent_traces table exists
    // If not, just log the trace (table will be created in migration)
    await (supabaseAdmin
      .from('multi_agent_traces') as any)
      .insert({
        lesson_id: lessonId,
        trace_data: result.trace,
        total_agents: new Set(result.trace.map((t: any) => t.agent)).size,
        total_duration_ms: result.totalDurationMs,
        complexity_score: complexity,
        success
      })
  } catch (error) {
    // Table might not exist yet, just log
    console.log('[Hybrid] Could not save multi-agent trace (table may not exist):', error)
    console.log('[Hybrid] Trace data:', JSON.stringify(result.trace, null, 2))
  }
}

// Removed unused utility functions - now using component kit system

/**
 * Get statistics on routing decisions
 */
export async function getRoutingStats(): Promise<{
  totalLessons: number
  singleAgentCount: number
  multiAgentCount: number
  averageComplexity: number
}> {
  try {
    const { data: traces } = await (supabaseAdmin
      .from('multi_agent_traces') as any)
      .select('complexity_score')
    
    const multiAgentCount = traces?.length || 0
    
    const { count: totalCount } = await (supabaseAdmin
      .from('lessons') as any)
      .select('*', { count: 'exact', head: true })
    
    const totalLessons = totalCount || 0
    const singleAgentCount = totalLessons - multiAgentCount
    
    const averageComplexity = traces && traces.length > 0
      ? traces.reduce((sum: number, t: any) => sum + (t.complexity_score || 0), 0) / traces.length
      : 0
    
    return {
      totalLessons,
      singleAgentCount,
      multiAgentCount,
      averageComplexity
    }
  } catch (error) {
    console.error('Error getting routing stats:', error)
    return {
      totalLessons: 0,
      singleAgentCount: 0,
      multiAgentCount: 0,
      averageComplexity: 0
    }
  }
}

